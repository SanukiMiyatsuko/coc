pdef.ts
export type Sort = "Prop" | "Type";
export type Name = string;
export type Position = { line: number; col: number };
export type Range = { start: Position; end: Position };
export type PType = PTerm;
export type Binder = VarBinder | DefBinder;
export type VarBinder = { tag: "Var"; names: Name[], type: PType; range: Range };
export type DefBinder = { tag: "Def"; name: Name; type?: PType; def: PType; range: Range };
export type PTerm =
  | { tag: "Sort"; name: Sort; range: Range }
  | { tag: "Variable"; name: Name; range: Range }
  | { tag: "Lambda"; binders: Binder[]; body: PTerm; range: Range }
  | { tag: "Pi"; binders: Binder[]; body: PType; range: Range }
  | { tag: "Arrow"; in: PType; out: PType; range: Range }
  | { tag: "Pair"; first: PTerm; second: PTerm; type?: PType; range: Range }
  | { tag: "First"; pair: PTerm; range: Range }
  | { tag: "Second"; pair: PTerm; range: Range }
  | { tag: "Sigma"; binders: Binder[]; body: PType; range: Range }
  | { tag: "Prod"; first: PType; second: PType; range: Range }
  | { tag: "Let"; name: Name; binders: Binder[]; type?: PType; def: PTerm; body: PTerm; range: Range }
  | { tag: "Apply"; apply: PTerm[]; range: Range };

export const varBinder = (names: string[], type: PType, bindRange: Range): VarBinder => ({ tag: "Var", names, type, range: bindRange });
export const defBinder = (name: string, type: PType | undefined, def: PType, bindRange: Range): DefBinder => ({ tag: "Def", name, type, def, range: bindRange });
export const Sort = (name: Sort, range: Range): PTerm => ({ tag: "Sort", name, range });
export const Variable = (name: string, range: Range): PTerm => ({ tag: "Variable", name, range });
export const Lambda = (binders: Binder[], body: PTerm, range: Range): PTerm => ({ tag: "Lambda", binders, body, range });
export const Pi = (binders: Binder[], body: PType, range: Range): PTerm => ({ tag: "Pi", binders, body, range });
export const Arrow = (input: PType, output: PType, range: Range): PTerm => ({ tag: "Arrow", in: input, out: output, range });
export const Pair = (first: PTerm, second: PTerm, type: PType | undefined, range: Range): PTerm => ({ tag: "Pair", first, second, type, range });
export const First = (pair: PTerm, range: Range): PTerm => ({ tag: "First", pair, range });
export const Second = (pair: PTerm, range: Range): PTerm => ({ tag: "Second", pair, range });
export const Sigma = (binders: Binder[], body: PType, range: Range): PTerm => ({ tag: "Sigma", binders, body, range });
export const Prod = (first: PType, second: PType, range: Range): PTerm => ({ tag: "Prod", first, second, range });
export const Let = (name: string, binders: Binder[], type: PType | undefined, def: PTerm, body: PTerm, range: Range): PTerm => ({ tag: "Let", name, binders, type, def, body, range });
export const Apply = (apply: PTerm[], range: Range): PTerm => ({ tag: "Apply", apply, range });

export type PLocalElement =
  | { tag: "Var"; name: Name; type: PTerm; range: Range }
  | { tag: "Def"; name: Name; type: PTerm | undefined; def: PTerm; range: Range };
export type PLocalContext = PLocalElement[];

export const pVarElem = (name: Name, type: PTerm, range: Range): PLocalElement => ({ tag: "Var", name, type, range });
export const pDefElem = (name: Name, type: PTerm | undefined, def: PTerm, range: Range): PLocalElement => ({ tag: "Def", name, type, def, range });

export type PGlobalElement =
  | { tag: "Var"; name: Name; type: PTerm; range: Range }
  | { tag: "Def"; name: Name; type: PTerm; def: PTerm; range: Range };
export type PGlobal = { elem: PGlobalElement; local: PLocalContext };

export const pGlobalElem = (name: Name, type: PTerm, def: PTerm | undefined, range: Range): PGlobalElement => def ? { tag: "Def", name, type, def, range } : { tag: "Var", name, type, range };
export const pGlobal = (elem: PGlobalElement, local: PLocalContext): PGlobal => ({ elem, local });

export type PGlobalContext = PGlobal[];

export function pFreeVariables(t: PTerm): Set<Name> {
  const acc = new Set<Name>();
  collect(t, new Set(), acc);
  return acc;
}

function collect(t: PTerm, env: Set<Name>, acc: Set<Name>) {
  switch (t.tag) {
    case "Sort":
      return;
    case "Variable": {
      if (!env.has(t.name))
        acc.add(t.name);
      return;
    }
    case "Lambda":
    case "Pi":
    case "Sigma":
    case "Let":
      break;
    case "Arrow": {
      collect(t.in, env, acc);
      collect(t.out, env, acc);
      return;
    }
    case "Pair": {
      collect(t.first, env, acc);
      collect(t.second, env, acc);
      if (t.type)
        collect(t.type, env, acc);
      return;
    }
    case "First":
    case "Second":
      return collect(t.pair, env, acc);
    case "Prod": {
      collect(t.first, env, acc);
      collect(t.second, env, acc);
      return;
    }
    case "Apply": {
      t.apply.forEach(e => collect(e, env, acc));
      return;
    }
  }
  for (const m of t.binders) {
    if (m.tag === "Var") {
      collect(m.type, env, acc);
      m.names.forEach(n => env.add(n));
    } else {
      if (m.type)
        collect(m.type, env, acc);
      collect(m.def, env, acc);
      env.add(m.name);
    }
  }
  if (t.tag === "Let") {
    if (t.type)
      collect(t.type, env, acc);
    collect(t.def, env, acc);
    env.add(t.name);
  }
  collect(t.body, env, acc);
  if (t.tag === "Let") env.delete(t.name);
  for (const m of t.binders) {
    if (m.tag === "Var")
      m.names.forEach(n => env.delete(n));
    else {
      env.delete(m.name);
    }
  }
  return;
}

result.ts
export type Succ<A> = { tag: "succ"; value: A }
export type Err<B> = { tag: "err"; err: B };
export type Result<A, B> = Succ<A> | Err<B>

export const succ = <A>(value: A): Succ<A> => ({ tag: "succ", value });
export const err = <B>(err: B): Err<B> => ({ tag: "err", err });

export const isSucc = <A, B>(vali: Result<A, B>): vali is Succ<A> => vali.tag === "succ";
export const isErr = <A, B>(vali: Result<A, B>): vali is Err<B> => vali.tag === "err";

tokenize.ts
import { type Position, type Range } from "./pdef";
import { type Result, succ, err } from "./result";

export type TokenizerError =
  | { tag: "UnexpectedChar"; char: string; pos: Position }
  | { tag: "UnclosedComment"; pos: Position };

export type TokenType =
  | "BLANKS"
  | "COMMENT"
  | "RES_DEF"
  | "RES_VAR"
  | "RES_PROP"
  | "RES_TYPE"
  | "RES_FUN"
  | "RES_FORALL"
  | "RES_EXIST"
  | "RES_LET"
  | "RES_IN"
  | "FAT_ARROW"
  | "ARROW"
  | "ASSIGN"
  | "LPAREN"
  | "RPAREN"
  | "COLON"
  | "COMMA"
  | "LANGLE"
  | "RANGLE"
  | "DOTONE"
  | "DOTTWO"
  | "AND"
  | "SEMICOLON"
  | "IDENT"
  | "EOF"

export type Token = {
  type: TokenType;
  value: string;
  range: Range;
};

type Pattern = { type: TokenType; re: RegExp };

const patterns: Pattern[] = [
  { type: "BLANKS", re: /^\s+/ },
  { type: "COMMENT", re: /^--[^\n]*(?:\n|$)/ },
  { type: "RES_DEF", re: /^(def)(?![\w'])/ },
  { type: "RES_VAR", re: /^(var)(?![\w'])/ },
  { type: "RES_PROP", re: /^(Prop)(?![\w'])/ },
  { type: "RES_TYPE", re: /^(Type)(?![\w'])/ },
  { type: "RES_FUN", re: /^(fun)(?![\w'])/ },
  { type: "RES_FORALL", re: /^(forall)(?![\w'])/ },
  { type: "RES_EXIST", re: /^(exist)(?![\w'])/ },
  { type: "RES_LET", re: /^(let)(?![\w'])/ },
  { type: "RES_IN", re: /^(in)(?![\w'])/ },
  { type: "FAT_ARROW", re: /^=>/ },
  { type: "ARROW", re: /^->/ },
  { type: "ASSIGN", re: /^:=/ },
  { type: "LPAREN", re: /^\(/ },
  { type: "RPAREN", re: /^\)/ },
  { type: "COLON", re: /^:/ },
  { type: "COMMA", re: /^,/ },
  { type: "LANGLE", re: /^</ },
  { type: "RANGLE", re: /^>/ },
  { type: "DOTONE", re: /^\.1/ },
  { type: "DOTTWO", re: /^\.2/ },
  { type: "AND", re: /^&/ },
  { type: "SEMICOLON", re: /^;/ },
  { type: "IDENT", re: /^[A-Za-z_][\w']*/ },
];

export class Tokenizer {
  private src: string;
  private pos = 0;
  private line = 1;
  private col = 1;

  constructor(src: string) {
    this.src = src.replace(/\r\n|\r/g, "\n");
  }

  private eof(): boolean {
    return this.pos >= this.src.length;
  }

  private advance(text: string) {
    for (const ch of text) {
      if (ch === "\n") {
        this.line++;
        this.col = 1;
      } else {
        this.col++;
      }
    }
    this.pos += text.length;
  }

  private currentPosition(): Position {
    return { line: this.line, col: this.col };
  }

  next(): Result<Token, TokenizerError> {
    if (this.eof()) {
      const p = this.currentPosition();
      return succ({
        type: "EOF",
        value: "",
        range: { start: p, end: p },
      });
    }
    const rest = this.src.slice(this.pos);
    if (rest.startsWith("{-")) {
      const close_index = rest.indexOf("-}", 2);
      if (close_index === -1)
        return err({
          tag: "UnclosedComment",
          pos: this.currentPosition(),
        });
      const value = rest.slice(0, close_index + 2);
      this.advance(value);
      return this.next();
    }
    const start = this.currentPosition();
    for (const { type, re } of patterns) {
      const m = re.exec(rest);
      if (!m)
        continue;
      const value = m[0];
      this.advance(value);
      if (type === "BLANKS" || type === "COMMENT")
        return this.next();
      const end = this.currentPosition();
      return succ({
        type,
        value,
        range: { start, end },
      });
    }
    return err({
      tag: "UnexpectedChar",
      char: this.src[this.pos],
      pos: this.currentPosition(),
    });
  }
}

context.ts
import { pFreeVariables, type PLocalElement, type PGlobalContext, type Range, type Name, type PGlobal } from "./pdef";
import { type Result, succ, err, isErr } from "./result";

type DepKind = "type" | "def";

export type CtxError =
  | { tag: "DuplicateGlobal"; name: Name; range: Range }
  | { tag: "DuplicateLocal"; name: Name; range: Range }
  | { tag: "SelfReference"; name: Name; kind: DepKind; range: Range }
  | { tag: "Undefined"; name: Name; in: Name; kind: DepKind; range: Range }
  | { tag: "Cycle"; path: { from: Name; to: Name; kind: DepKind }[]; range: Range };

type Dependency = { to: Name; kind: DepKind };
type DepGraph = Map<string, Dependency[]>;
type GlobalInfos = Set<Name>;
type RangeMap = Map<string, Range>;

function globalDepsOf(ge: PGlobal): Dependency[] {
  const bound = new Set<Name>();
  for (const e of ge.local) {
    bound.add(e.name);
  };
  const deps: Dependency[] = [];
  for (const v of pFreeVariables(ge.elem.type)) {
    if (!bound.has(v))
      deps.push({ to: v, kind: "type" });
  }
  if (ge.elem.tag === "Def")
    for (const v of pFreeVariables(ge.elem.def)) {
      if (!bound.has(v))
        deps.push({ to: v, kind: "def" });
    }
  return deps;
}

function localDepsOf(e: PLocalElement): Dependency[] {
  const deps: Dependency[] = [];
  if (e.tag === "Var")
    for (const v of pFreeVariables(e.type)) {
      deps.push({ to: v, kind: "type" });
    }
  if (e.tag === "Def") {
    if (e.type)
      for (const v of pFreeVariables(e.type)) {
        deps.push({ to: v, kind: "type" });
      }
    for (const v of pFreeVariables(e.def)) {
      deps.push({ to: v, kind: "def" });
    }
  }
  return deps;
}

function buildDefInfo(ctx: PGlobalContext): Result<GlobalInfos, CtxError> {
  const globals: GlobalInfos = new Set();
  for (const ge of ctx) {
    const elem = ge.elem
    if (globals.has(elem.name))
      return err({ tag: "DuplicateGlobal", name: elem.name, range: elem.range });
    const local: Name[] = [];
    for (const e of ge.local) {
      if (local.find(x => x === e.name))
        return err({ tag: "DuplicateLocal", name: e.name, range: e.range });
      local.push(e.name);
    }
    globals.add(elem.name);
  }
  return succ(globals);
}

function buildDepGraph(ctx: PGlobalContext, info: GlobalInfos): Result<{ graph: DepGraph; rangeMap: RangeMap }, CtxError> {
  const graph: DepGraph = new Map();
  const rangeMap: RangeMap = new Map();
  for (const g of ctx) {
    const gNode = `global:${g.elem.name}`;
    const globalDeps = globalDepsOf(g);
    for (const dep of globalDeps) {
      if (dep.to === g.elem.name)
        return err({
          tag: "SelfReference",
          name: g.elem.name,
          kind: dep.kind,
          range: g.elem.range
        });
      if (!info.has(dep.to))
        return err({
          tag: "Undefined",
          name: dep.to,
          in: g.elem.name,
          kind: dep.kind,
          range: g.elem.range
        });
    }
    graph.set(gNode, globalDeps);
    rangeMap.set(gNode, g.elem.range);
    const seenLocals = new Set<Name>();
    for (const localElem of g.local) {
      const lNode = `local:${g.elem.name}:${localElem.name}`;
      const localDeps = localDepsOf(localElem);
      for (const dep of localDeps) {
        if (dep.to === localElem.name)
          return err({
            tag: "SelfReference",
            name: localElem.name,
            kind: dep.kind,
            range: localElem.range
          });
        const isDefinedLocal = seenLocals.has(dep.to);
        const isDefinedGlobal = info.has(dep.to);
        if (!isDefinedLocal && !isDefinedGlobal)
          return err({
            tag: "Undefined",
            name: dep.to,
            in: localElem.name,
            kind: dep.kind,
            range: localElem.range
          });
      }
      graph.set(lNode, localDeps);
      rangeMap.set(lNode, localElem.range);
      seenLocals.add(localElem.name);
    }
  }
  return succ({ graph, rangeMap });
}

function depToNode(fromNode: string, dep: Dependency): string {
  if (fromNode.startsWith("global:"))
    return `global:${dep.to}`;
  const li = fromNode.split(":");
  return `local:${li[1]}:${dep.to}`;
}

function detectCycle(
  graph: DepGraph,
  ranges: Map<string, Range>
): Result<true, CtxError> {
  const visited = new Set<string>();
  const stack: string[] = [];
  const onStack = new Set<string>();

  function dfs(v: string): Result<true, CtxError> {
    visited.add(v);
    stack.push(v);
    onStack.add(v);

    const deps = graph.get(v) ?? [];
    for (const dep of deps) {
      const to = depToNode(v, dep);
      if (!graph.has(to))
        continue;
      if (!visited.has(to)) {
        const r = dfs(to);
        if (isErr(r))
          return r;
      } else if (onStack.has(to)) {
        const idx = stack.indexOf(to);
        const cyclePath = stack.slice(idx).map((_, i) => ({
          from: stack[idx + i],
          to: stack[idx + i + 1] ?? to,
          kind: dep.kind
        }));
        return err({
          tag: "Cycle",
          path: cyclePath,
          range: ranges.get(to)!
        });
      }
    }
    stack.pop();
    onStack.delete(v);
    return succ(true);
  }
  for (const v of graph.keys()) {
    if (!visited.has(v)) {
      const r = dfs(v);
      if (isErr(r))
        return r;
    }
  }
  return succ(true);
}


export function checkGlobalContext(ctx: PGlobalContext): Result<true, CtxError> {
  const infoR = buildDefInfo(ctx);
  if (isErr(infoR))
    return infoR;
  const graphR = buildDepGraph(ctx, infoR.value);
  if (isErr(graphR))
    return graphR;
  const acyclicR = detectCycle(graphR.value.graph, graphR.value.rangeMap);
  if (isErr(acyclicR))
    return acyclicR;
  return succ(true);
}

parse.ts
import { type CtxError, checkGlobalContext } from "./context";
import { type Name, type Range, type PType, type Binder, type PTerm, varBinder, Sort, Variable, Lambda, Pi, Arrow, Pair, First, Second, Sigma, Prod, Let, Apply, pVarElem, pDefElem, defBinder, type PGlobalContext, type PLocalContext, pGlobalElem, pGlobal, type VarBinder, type PGlobalElement } from "./pdef";
import { type Result, succ, err, isErr, isSucc } from "./result";
import { type TokenizerError, type Tokenizer, type TokenType, type Token } from "./tokenize";

type ParseError =
  | { tag: "Tokenizer"; error: TokenizerError }
  | { tag: "Context"; error: CtxError }
  | { tag: "UnexpectedToken"; expected: TokenType; actual: Token };

export type ParseNode = {
  id: number;
  label: string;
  children: ParseNode[];
  range?: Range;
  status: "enter" | "success" | "error";
  error?: ParseError;
};

export class Parser {
  private tokenizer: Tokenizer;
  private curr!: Token;
  private prev!: Token;
  private traceStack: ParseNode[] = [];
  private root: ParseNode | null = null;
  private nextNodeId = 0;

  constructor(tokenizer: Tokenizer) {
    this.tokenizer = tokenizer;
    this.advance();
  }

  getTrace(): ParseNode | null {
    return this.root;
  }

  private advance(): Result<void, ParseError> {
    const res = this.tokenizer.next();
    if (isErr(res)) {
      return err({ tag: "Tokenizer", error: res.err });
    }
    this.prev = this.curr;
    this.curr = res.value;
    return succ(undefined);
  }

  private withNode<T>(
    label: string,
    fn: () => Result<T, ParseError>
  ): Result<T, ParseError> {
    const startToken = this.curr;
    const node: ParseNode = {
      id: this.nextNodeId++,
      label,
      children: [],
      status: "enter",
    };
    if (this.traceStack.length === 0) {
      this.root = node;
    } else {
      this.traceStack[this.traceStack.length - 1].children.push(node);
    }
    this.traceStack.push(node);
    const result = fn();
    this.traceStack.pop();
    const maybeEndToken = this.prev ?? startToken;
    node.range = {
      start: startToken.range.start,
      end: maybeEndToken.range.end,
    };
    if (isErr(result)) {
      node.status = "error";
      node.error = result.err;
      return result;
    }
    node.status = "success";
    return result;
  }

  private expect(type: TokenType): Result<Token, ParseError> {
    const t = this.curr;
    if (t.type !== type)
      return err({
        tag: "UnexpectedToken",
        expected: type,
        actual: t,
      });
    const adv = this.advance();
    if (isErr(adv))
      return adv;
    return succ(t);
  }

  private parseOpenBinder(): Result<VarBinder, ParseError> {
    return this.withNode("parseOpenBinder", () => {
      const start = this.curr.range.start;
      const name = this.expect("IDENT");
      if (isErr(name))
        return name;
      const names = [name.value.value];
      let cur = this.curr;
      while (cur.type === "IDENT") {
        names.push(cur.value);
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        cur = this.curr;
      }
      const colon = this.expect("COLON");
      if (isErr(colon))
        return colon;
      const type = this.parseTerm();
      if (isErr(type))
        return type;
      const end = this.prev.range.end;
      return succ(varBinder(names, type.value, { start, end }));
    });
  }

  private parseVariableBinder(): Result<VarBinder, ParseError> {
    return this.withNode("parseVariableBinder", () => {
      const start = this.curr.range.start;
      const lparen = this.expect("LPAREN");
      if (isErr(lparen))
        return lparen;
      const open_binder = this.parseOpenBinder();
      if (isErr(open_binder))
        return open_binder;
      const { names, type } = open_binder.value;
      const rparen = this.expect("RPAREN");
      if (isErr(rparen))
        return rparen;
      const end = this.prev.range.end;
      return succ(varBinder(names, type, { start, end }));
    });
  }

  private parseClosedBinder(): Result<Binder, ParseError> {
    return this.withNode("parseClosedBinder", () => {
      const start = this.curr.range.start;
      const lparen = this.expect("LPAREN");
      if (isErr(lparen))
        return lparen;
      const ident = this.expect("IDENT");
      if (isErr(ident))
        return ident;
      const name = ident.value.value;
      let cur = this.curr;
      if (cur.type === "IDENT") {
        const names = [name];
        while (cur.type === "IDENT") {
          names.push(cur.value);
          const adv = this.advance();
          if (isErr(adv))
            return adv;
          cur = this.curr;
        }
        const colon = this.expect("COLON");
        if (isErr(colon))
          return colon;
        const type = this.parseTerm();
        if (isErr(type))
          return type;
        const rparen = this.expect("RPAREN");
        if (isErr(rparen))
          return rparen;
        const end = this.prev.range.end;
        return succ(varBinder(names, type.value, { start, end }) as Binder);
      }
      if (isSucc(this.expect("ASSIGN"))) {
        const def = this.parseTerm();
        if (isErr(def))
          return def;
        const rparen = this.expect("RPAREN");
        if (isErr(rparen))
          return rparen;
        const end = this.prev.range.end;
        return succ(defBinder(name, undefined, def.value, { start, end }) as Binder);
      }
      const colon = this.expect("COLON");
      if (isErr(colon))
        return colon;
      const type = this.parseTerm();
      if (isErr(type))
        return type;
      if (isSucc(this.expect("RPAREN"))) {
        const end = this.prev.range.end;
        return succ(varBinder([name], type.value, { start, end }) as Binder);
      }
      const assign = this.expect("ASSIGN");
      if (isErr(assign))
        return assign;
      const def = this.parseTerm();
      if (isErr(def))
        return def;
      const rparen = this.expect("RPAREN");
      if (isErr(rparen))
        return rparen;
      const end = this.prev.range.end;
      return succ(defBinder(name, type.value, def.value, { start, end }) as Binder);
    });
  }

  private parseBinder(): Result<Binder[], ParseError> {
    return this.withNode("parseBinder", () => {
      const t = this.curr;
      if (t.type === "IDENT") {
        const open_binder = this.parseOpenBinder();
        if (isErr(open_binder))
          return open_binder;
        return succ([open_binder.value]);
      }
      const binder = this.parseVariableBinder();
      if (isErr(binder))
        return binder;
      const binders: Binder[] = [binder.value];
      let cur = this.curr;
      while (cur.type === "LPAREN") {
        const b = this.parseClosedBinder();
        if (isErr(b))
          return b;
        binders.push(b.value);
        cur = this.curr;
      }
      return succ(binders);
    });
  }

  private parseLam(): Result<PTerm, ParseError> {
    return this.withNode("parseLam", () => {
      const start = this.curr.range.start;
      const res_fun = this.expect("RES_FUN");
      if (isErr(res_fun))
        return res_fun;
      const binders = this.parseBinder();
      if (isErr(binders))
        return binders;
      const fat_arrow = this.expect("FAT_ARROW");
      if (isErr(fat_arrow))
        return fat_arrow;
      const body = this.parseTerm();
      if (isErr(body))
        return body;
      const end = this.prev.range.end;
      return succ(Lambda(binders.value, body.value, { start, end }));
    });
  }

  private parsePi(): Result<PTerm, ParseError> {
    return this.withNode("parsePi", () => {
      const start = this.curr.range.start;
      const res_forall = this.expect("RES_FORALL");
      if (isErr(res_forall))
        return res_forall;
      const binders = this.parseBinder();
      if (isErr(binders))
        return binders;
      const comma = this.expect("COMMA");
      if (isErr(comma))
        return comma;
      const body = this.parseTerm();
      if (isErr(body))
        return body;
      const end = this.prev.range.end;
      return succ(Pi(binders.value, body.value, { start, end }));
    });
  }

  private parsePair(): Result<PTerm, ParseError> {
    return this.withNode("parsePair", () => {
      const start = this.curr.range.start;
      const langle = this.expect("LANGLE");
      if (isErr(langle))
        return langle;
      const first = this.parseTerm();
      if (isErr(first))
        return first;
      const comma = this.expect("COMMA");
      if (isErr(comma))
        return comma;
      const second = this.parseTerm();
      if (isErr(second))
        return second;
      const rangle = this.expect("RANGLE");
      if (isErr(rangle))
        return rangle;
      let type: PType | undefined = undefined;
      if (this.curr.type === "COLON") {
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        const assertion = this.parseTerm();
        if (isErr(assertion))
          return assertion;
        type = assertion.value;
      }
      const end = this.prev.range.end;
      return succ(Pair(first.value, second.value, type, { start, end }));
    });
  }

  private parseSigma(): Result<PTerm, ParseError> {
    return this.withNode("parseSigma", () => {
      const start = this.curr.range.start;
      const res_exist = this.expect("RES_EXIST");
      if (isErr(res_exist))
        return res_exist;
      const binders = this.parseBinder();
      if (isErr(binders))
        return binders;
      const comma = this.expect("COMMA");
      if (isErr(comma))
        return comma;
      const body = this.parseTerm();
      if (isErr(body))
        return body;
      const end = this.prev.range.end;
      return succ(Sigma(binders.value, body.value, { start, end }));
    });
  }

  private parseToEndOfBinder(): Result<{ name: Name; binders: Binder[] }, ParseError> {
    return this.withNode("parseToEndOfBinder", () => {
      const ident = this.expect("IDENT");
      if (isErr(ident))
        return ident;
      const name = ident.value.value;
      const binders = [];
      let cur = this.curr;
      while (cur.type === "LPAREN") {
        const b = this.parseClosedBinder();
        if (isErr(b))
          return b;
        binders.push(b.value);
        cur = this.curr;
      }
      return succ({ name, binders });
    });
  }

  private parseLet(): Result<PTerm, ParseError> {
    return this.withNode("parseLet", () => {
      const start = this.curr.range.start;
      const res_let = this.expect("RES_LET");
      if (isErr(res_let))
        return res_let;
      const nameBinders = this.parseToEndOfBinder();
      if (isErr(nameBinders))
        return nameBinders;
      const { name, binders } = nameBinders.value;
      let type: PTerm | undefined = undefined;
      if (this.curr.type === "COLON") {
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        const resulttype = this.parseTerm();
        if (isErr(resulttype))
          return resulttype;
        type = resulttype.value;
      }
      const assign = this.expect("ASSIGN");
      if (isErr(assign))
        return assign;
      const def = this.parseTerm();
      if (isErr(def))
        return def;
      const res_in = this.expect("RES_IN");
      if (isErr(res_in))
        return res_in;
      const body = this.parseTerm();
      if (isErr(body))
        return body;
      const end = this.prev.range.end;
      return succ(Let(name, binders, type, def.value, body.value, { start, end }));
    });
  }

  private parseAtom(): Result<PTerm, ParseError> {
    return this.withNode("parseAtom", () => {
      const t = this.curr;
      if (t.type === "LANGLE")
        return this.parsePair();
      if (isSucc(this.expect("RES_PROP")))
        return succ(Sort("Prop", t.range));
      if (isSucc(this.expect("RES_TYPE")))
        return succ(Sort("Type", t.range));
      if (isSucc(this.expect("IDENT")))
        return succ(Variable(t.value, t.range));
      const lparen = this.expect("LPAREN");
      if (isErr(lparen))
        return lparen;
      const term = this.parseTerm();
      if (isErr(term))
        return term;
      const rparen = this.expect("RPAREN");
      if (isErr(rparen))
        return rparen;
      return term;
    });
  }

  private parseProj(): Result<PTerm, ParseError> {
    return this.withNode("parseProj", () => {
      const start = this.curr.range.start;
      const atom = this.parseAtom();
      if (isErr(atom))
        return atom;
      let cur = atom.value;
      let token = this.curr;
      while (token.type === "DOTONE"
        || token.type === "DOTTWO") {
        if (token.type === "DOTONE")
          cur = First(cur, { start, end: token.range.end });
        else
          cur = Second(cur, { start, end: token.range.end });
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        token = this.curr;
      }
      return succ(cur);
    });
  }

  private isAppStart(token: Token): boolean {
    return token.type === "RES_PROP"
      || token.type === "RES_TYPE"
      || token.type === "IDENT"
      || token.type === "LPAREN"
      || token.type === "LANGLE";
  }

  private parseApp(): Result<PTerm, ParseError> {
    return this.withNode("parseApp", () => {
      const start = this.curr.range.start;
      const first = this.parseProj();
      if (isErr(first))
        return first;
      const cur = [first.value];
      while (this.isAppStart(this.curr)) {
        const arg = this.parseProj();
        if (isErr(arg))
          return arg;
        cur.push(arg.value);
      }
      const end = this.prev.range.end;
      if (cur.length === 1)
        return succ(first.value);
      return succ(Apply(cur, { start, end }));
    });
  }

  private parseProd(): Result<PTerm, ParseError> {
    return this.withNode("parseProd", () => {
      const start = this.curr.range.start;
      const first = this.parseApp();
      if (isErr(first))
        return first;
      let cur = first.value;
      while (this.curr.type === "AND") {
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        const body = this.parseApp();
        if (isErr(body))
          return body;
        const end = this.prev.range.end;
        cur = Prod(cur, body.value, { start, end });
      }
      return succ(cur);
    });
  }

  private parseArrow(): Result<PTerm, ParseError> {
    return this.withNode("parseArrow", () => {
      const start = this.curr.range.start;
      const left = this.parseProd();
      if (isErr(left))
        return left;
      if (this.curr.type === "ARROW") {
        const adv = this.advance();
        if (isErr(adv))
          return adv;
        const right = this.parseTerm();
        if (isErr(right))
          return right;
        const end = this.prev.range.end;
        return succ(Arrow(left.value, right.value, { start, end }));
      }
      return left;
    });
  }

  private parseTerm(): Result<PTerm, ParseError> {
    return this.withNode("parseTerm", () => {
      const t = this.curr;
      if (t.type === "RES_FUN")
        return this.parseLam();
      if (t.type === "RES_FORALL")
        return this.parsePi();
      if (t.type === "RES_EXIST")
        return this.parseSigma();
      if (t.type === "RES_LET")
        return this.parseLet();
      return this.parseArrow();
    });
  }

  private parseDef(): Result<{ elem: PGlobalElement, binders: Binder[] }, ParseError> {
    return this.withNode("parseDef", () => {
      const start = this.curr.range.start;
      if (isSucc(this.expect("RES_DEF"))) {
        const nameBinders = this.parseToEndOfBinder();
        if (isErr(nameBinders))
          return nameBinders;
        const name = nameBinders.value.name;
        const binders = nameBinders.value.binders;
        const colon = this.expect("COLON");
        if (isErr(colon))
          return colon;
        const type = this.parseTerm();
        if (isErr(type))
          return type;
        const assign = this.expect("ASSIGN");
        if (isErr(assign))
          return assign;
        const def = this.parseTerm();
        if (isErr(def))
          return def;
        const semicolon = this.expect("SEMICOLON");
        if (isErr(semicolon))
          return semicolon;
        const end = this.prev.range.end;
        const elem = pGlobalElem(name, type.value, def.value, { start, end });
        return succ({ elem, binders });
      }
      const nameBinders = this.parseToEndOfBinder();
      if (isErr(nameBinders))
        return nameBinders;
      const name = nameBinders.value.name;
      const binders = nameBinders.value.binders;
      const colon = this.expect("COLON");
      if (isErr(colon))
        return colon;
      const type = this.parseTerm();
      if (isErr(type))
        return type;
      const semicolon = this.expect("SEMICOLON");
      if (isErr(semicolon))
        return semicolon;
      const end = this.prev.range.end;
      const elem = pGlobalElem(name, type.value, undefined, { start, end });
      return succ({ elem, binders });
    });
  }

  parseProgram(): Result<PGlobalContext, ParseError> {
    return this.withNode("parseProgram", () => {
      const defs: PGlobalContext = [];
      while (this.curr.type !== "EOF") {
        const def = this.parseDef();
        if (isErr(def))
          return def;
        const local: PLocalContext = [];
        for (const e of def.value.binders) {
          if (e.tag === "Var")
            for (const n of e.names) {
              local.push(pVarElem(n, e.type, e.range));
            }
          if (e.tag === "Def")
            local.push(pDefElem(e.name, e.type, e.def, e.range));
        }
        const global = pGlobal(def.value.elem, local);
        defs.push(global);
      }
      const cj = checkGlobalContext(defs);
      if (isErr(cj))
        return err({ tag: "Context", error: cj.err });
      return succ(defs);
    });
  }
}

ast.ts
import { type Name, type Sort } from "./pdef";

export type Term =
  | { tag: "Sort"; name: Sort }
  | { tag: "Var"; name: Name }
  | { tag: "Lam"; name: Name; type: Term; body: Term }
  | { tag: "Pi"; name: Name; type: Term; body: Term }
  | { tag: "Pair"; fst: Term; snd: Term; as?: Term }
  | { tag: "Fst"; pair: Term }
  | { tag: "Snd"; pair: Term }
  | { tag: "Sig"; name: Name; type: Term; body: Term }
  | { tag: "Let"; name: Name; type?: Term; def: Term; body: Term }
  | { tag: "App"; fun: Term; arg: Term };

export const sort = (name: Sort): Term => ({ tag: "Sort", name });
export const varia = (name: Name): Term => ({ tag: "Var", name });
export const lam = (name: Name, type: Term, body: Term): Term => ({ tag: "Lam", name, type, body });
export const pi = (name: Name, type: Term, body: Term): Term => ({ tag: "Pi", name, type, body });
export const pair = (fst: Term, snd: Term, as?: Term): Term => ({ tag: "Pair", fst, snd, as });
export const fst = (pair: Term): Term => ({ tag: "Fst", pair });
export const snd = (pair: Term): Term => ({ tag: "Snd", pair });
export const sig = (name: Name, type: Term, body: Term): Term => ({ tag: "Sig", name, type, body });
export const letIn = (name: Name, type: Term | undefined, def: Term, body: Term): Term => ({ tag: "Let", name, type, def, body });
export const app = (fun: Term, arg: Term): Term => ({ tag: "App", fun, arg });

export type CtxElement =
  | { tag: "Var"; name: Name; type: Term }
  | { tag: "Def"; name: Name; type: Term; def: Term };

export type Context = CtxElement[];

export const ctxElem = (name: Name, type: Term, def?: Term): CtxElement =>
  def ? { tag: "Def", name, type, def } : { tag: "Var", name, type };

export type JudgContext = { global: Context; local: Context };

export const judgCtx = (global: Context, local: Context): JudgContext => ({ global, local });

export type Judgment =
  | { tag: "nomal"; context: JudgContext; term: Term; type: Term }
  | { tag: "WF"; context: JudgContext };

trans.ts
import * as P from "./pdef";
import * as A from "./ast";

const anon = "_";

function elabBinders(
  bs: P.Binder[],
  body: A.Term,
  f: (name: P.Name, type: A.Term, body: A.Term) => A.Term
): A.Term {
  return bs.reduceRight((acc, b) => {
    if (b.tag === "Var")
      return b.names.reduceRight(
        (acc2, n) => f(n, elabTerm(b.type), acc2),
        acc
      );
    else
      return A.letIn(
        b.name,
        b.type ? elabTerm(b.type) : undefined,
        elabTerm(b.def),
        acc
      );
  }, body);
}

export function elabTerm(t: P.PTerm): A.Term {
  switch (t.tag) {
    case "Sort":
      return A.sort(t.name);
    case "Variable":
      return A.varia(t.name);
    case "Lambda":
      return elabBinders(
        t.binders,
        elabTerm(t.body),
        A.lam
      );
    case "Pi":
      return elabBinders(
        t.binders,
        elabTerm(t.body),
        A.pi
      );
    case "Arrow":
      return A.pi(
        anon,
        elabTerm(t.in),
        elabTerm(t.out)
      );
    case "Pair":
      return A.pair(
        elabTerm(t.first),
        elabTerm(t.second),
        t.type ? elabTerm(t.type) : undefined
      );
    case "First":
      return A.fst(elabTerm(t.pair));
    case "Second":
      return A.snd(elabTerm(t.pair));
    case "Sigma":
      return elabBinders(
        t.binders,
        elabTerm(t.body),
        A.sig
      );
    case "Prod":
      return A.sig(
        anon,
        elabTerm(t.first),
        elabTerm(t.second)
      );
    case "Let": {
      const defType = t.type
        ? elabBinders(
            t.binders,
            elabTerm(t.type),
            A.pi
          )
        : undefined;
      const defCore = elabBinders(
        t.binders,
        elabTerm(t.def),
        A.lam
      );
      return A.letIn(
        t.name,
        defType,
        defCore,
        elabTerm(t.body)
      );
    }
    case "Apply": {
      const [head, ...args] = t.apply.map(elabTerm);
      return args.reduce((f, a) => A.app(f, a), head);
    }
  }
}

export function elabGlobalContext(pgc: P.PGlobalContext): A.Context {
  const ctx: A.Context = [];
  for (const g of pgc) {
    let term = elabTerm(g.elem.type);
    for (let i = g.local.length - 1; i >= 0; i--) {
      const e = g.local[i];
      if (e.tag === "Var") {
        term = A.pi(e.name, elabTerm(e.type), term);
      } else {
        term = A.letIn(
          e.name,
          e.type ? elabTerm(e.type) : undefined,
          elabTerm(e.def),
          term
        );
      }
    }
    if (g.elem.tag === "Var") {
      ctx.push(A.ctxElem(g.elem.name, term));
    } else {
      ctx.push(
        A.ctxElem(
          g.elem.name,
          term,
          elabTerm(g.elem.def)
        )
      );
    }
  }
  return ctx;
}

definition.ts
import { type Name } from "./pdef";
import { type Term, varia, lam, pi, pair, fst, snd, sig, letIn, app } from "./ast";

export function freeVar(t: Term, acc: Set<Name> = new Set()): Set<Name> {
  switch (t.tag) {
    case "Sort":
      return acc;
    case "Var": {
      acc.add(t.name);
      return acc;
    }
    case "Lam":
    case "Pi":
    case "Sig":
    case "Let":
      break;
    case "Pair": {
      freeVar(t.fst, acc);
      freeVar(t.snd, acc);
      if (t.as)
        freeVar(t.as, acc);
      return acc;
    }
    case "Fst":
    case "Snd":
      return freeVar(t.pair, acc);
    case "App": {
      freeVar(t.fun, acc);
      freeVar(t.arg, acc);
      return acc;
    }
  }
  if (t.type)
    freeVar(t.type, acc);
  if (t.tag === "Let")
    freeVar(t.def, acc);
  const bf = freeVar(t.body);
  bf.delete(t.name);
  bf.forEach(v => acc.add(v));
  return acc;
}

function freshName(base: Name, used: Set<Name> = new Set()): Name {
  if (!used.has(base)) return base;
  const match = base.match(/_(\d+)$/);
  let i = match ? Number(match[1]) + 1 : 0;
  const sliced = match ? base.slice(0, match.index) : base;
  let cand: Name;
  do {
    cand = `${sliced}_${i}`;
    i += 1;
  } while (used.has(cand));
  return cand;
}

function substInter(t: Term, v: Name, u: Term, fu: Set<Name>): Term {
  switch (t.tag) {
    case "Sort":
      return t;
    case "Var":
      return t.name === v ? u : t;
    case "Lam":
    case "Pi":
    case "Sig": {
      const x = t.name;
      const pt = substInter(t.type, v, u, fu);
      if (x === v)
        return t.tag === "Lam"
          ? lam(x, pt, t.body)
          : t.tag === "Pi"
            ? pi(x, pt, t.body)
            : sig(x, pt, t.body);
      if (!fu.has(x)) {
        const body = substInter(t.body, v, u, fu);
        return t.tag === "Lam"
          ? lam(x, pt, body)
          : t.tag === "Pi"
            ? pi(x, pt, body)
            : sig(x, pt, body);
      }
      const used = new Set(fu);
      used.add(v);
      freeVar(t, used);
      const y = freshName(x, used);
      const rename = substInter(t.body, x, varia(y), new Set([y]));
      const body = substInter(rename, v, u, fu);
      return t.tag === "Lam"
        ? lam(y, pt, body)
        : t.tag === "Pi"
          ? pi(y, pt, body)
          : sig(y, pt, body);
    }
    case "Pair": {
      const fun = substInter(t.fst, v, u, fu);
      const arg = substInter(t.snd, v, u, fu);
      let type = undefined;
      if (t.as)
        type = substInter(t.as, v, u, fu);
      return pair(fun, arg, type);
    }
    case "Fst":
      return fst(substInter(t.pair, v, u, fu));
    case "Snd":
      return snd(substInter(t.pair, v, u, fu));
    case "Let": {
      const x = t.name;
      const pt = t.type ? substInter(t.type, v, u, fu) : undefined;
      const def = substInter(t.def, v, u, fu);
      if (x === v)
        return letIn(x, pt, def!, t.body);
      if (!fu.has(x)) {
        const body = substInter(t.body, v, u, fu);
        return letIn(x, pt, def!, body);
      }
      const used = new Set(fu);
      used.add(v);
      freeVar(t, used);
      const y = freshName(x, used);
      const rename = substInter(t.body, x, varia(y), new Set([y]));
      const body = substInter(rename, v, u, fu);
      return letIn(y, pt, def, body);
    }
    case "App": {
      const fun = substInter(t.fun, v, u, fu);
      const arg = substInter(t.arg, v, u, fu);
      return app(fun, arg);
    }
  }
}

export function subst(t: Term, v: Name, u: Term): Term {
  const ft = freeVar(t);
  if (!ft.has(v))
    return t;
  const fu = freeVar(u);
  return substInter(t, v, u, fu);
}

export function alphaEq(t: Term, u: Term): boolean {
  switch (t.tag) {
    case "Sort":
    case "Var":
      return t.tag === u.tag
        && t.name === u.name;
    case "Lam":
    case "Pi":
    case "Sig": {
      if (t.tag !== u.tag)
        return false;
      const used = new Set([t.name, u.name]);
      freeVar(t.body, used);
      freeVar(u.body, used);
      const fresh = freshName(t.name, used);
      const newVar = varia(fresh);
      return alphaEq(t.type, u.type)
        && alphaEq(
          subst(t.body, t.name, newVar),
          subst(u.body, u.name, newVar)
        );
    }
    case "Pair": {
      if (t.tag !== u.tag)
        return false;
      if (!alphaEq(t.fst, u.fst))
        return false;
      if (!alphaEq(t.snd, u.snd))
        return false;
      if (t.as === undefined && u.as === undefined)
        return true;
      if (t.as === undefined || u.as === undefined)
        return false;
      return alphaEq(t.as, u.as);
    }
    case "Fst":
    case "Snd":
      return t.tag === u.tag
        && alphaEq(t.pair, u.pair);
    case "Let": {
      if (t.tag !== u.tag)
        return false;
      const used = new Set([t.name, u.name]);
      freeVar(t.body, used);
      freeVar(u.body, used);
      const fresh = freshName(t.name, used);
      const newVar = varia(fresh);
      const subt = subst(t.body, t.name, newVar);
      const subu = subst(u.body, u.name, newVar);
      if (!alphaEq(t.def, u.def))
        return false;
      if (!alphaEq(subt, subu))
        return false;
      if (t.type === undefined && u.type === undefined)
        return true;
      if (t.type === undefined || u.type === undefined)
        return false;
      return alphaEq(t.type, u.type);
    }
    case "App":
      return t.tag === u.tag
        && alphaEq(t.fun, u.fun)
        && alphaEq(t.arg, u.arg);
  }
}

typecheck.ts
import { type Sort, type Name } from "./pdef";
import { type Term, sort, lam, pi, pair, fst, snd, sig, letIn, app, varia, type CtxElement, type Context, ctxElem, type JudgContext, judgCtx } from "./ast";
import { type Result, succ, err, isErr } from "./result";
import { subst, alphaEq } from "./definition";

type TypeError =
  | { tag: "TypeHasNoType" }
  | { tag: "UnboundVariable"; name: Name }
  | { tag: "ExpectedSort"; actual: Term }
  | { tag: "ImpossibleCombination", sort0: Sort, sort1: Sort }
  | { tag: "ExpectedPi"; fun: Term; actual: Term }
  | { tag: "ExpectedSigma"; pair: Term; actual: Term }
  | { tag: "TypeMismatch"; expected: Term; actual: Term };

type WFError = { error: TypeError; at: CtxElement };

function dszNF(jc: JudgContext, t: Term): Term {
  switch (t.tag) {
    case "Sort":
      return t;
    case "Var": {
      const le = jc.local.slice().reverse().find(e => e.name === t.name);
      if (le && le.tag === "Def")
        return dszNF(jc, le.def);
      const ge = jc.global.slice().reverse().find(e => e.name === t.name);
      if (ge && ge.tag === "Def")
        return dszNF(jc, ge.def);
      return t;
    }
    case "Lam":
      return lam(t.name, dszNF(jc, t.type), dszNF(jc, t.body));
    case "Pi":
      return pi(t.name, dszNF(jc, t.type), dszNF(jc, t.body));
    case "Pair":
      return pair(dszNF(jc, t.fst), dszNF(jc, t.snd), t.as ? dszNF(jc, t.as) : undefined);
    case "Fst": {
      if (t.pair.tag === "Pair")
        return dszNF(jc, t.pair.fst);
      return fst(dszNF(jc, t.pair));
    }
    case "Snd": {
      if (t.pair.tag === "Pair")
        return dszNF(jc, t.pair.snd);
      return snd(dszNF(jc, t.pair));
    }
    case "Sig":
      return sig(t.name, dszNF(jc, t.type), dszNF(jc, t.body));
    case "Let":
      return dszNF(jc, subst(t.body, t.name, t.def));
    case "App":
      return app(dszNF(jc, t.fun), dszNF(jc, t.arg));
  }
}

function headNF(t: Term): Term {
  switch (t.tag) {
    case "Sort":
    case "Var":
    case "Lam":
      return t;
    case "Pi":
      return pi(t.name, headNF(t.type), headNF(t.body));
    case "Pair":
      return pair(headNF(t.fst), headNF(t.snd), t.as ? headNF(t.as) : undefined);
    case "Fst":
      return fst(headNF(t.pair));
    case "Snd":
      return snd(headNF(t.pair));
    case "Sig":
      return sig(t.name, headNF(t.type), headNF(t.body));
    case "Let":
      return letIn(t.name, t.type ? headNF(t.type) : undefined, headNF(t.def), headNF(t.body));
    case "App": {
      const fun = headNF(t.fun);
      if (fun.tag === "Lam")
        return headNF(subst(fun.body, fun.name, t.arg));
      return app(fun, t.arg);
    }
  }
}

function ahEq(jc: JudgContext, t: Term, u: Term): boolean {
  const tWhnf = headNF(dszNF(jc, t));
  const uWhnf = headNF(dszNF(jc, u));
  if (tWhnf.tag === "Lam") {
    const tname = tWhnf.name;
    const tbody = tWhnf.body;
    const local = jc.local.slice();
    local.push(ctxElem(tname, tWhnf.type));
    return ahEq(judgCtx(jc.global, local), tbody, app(uWhnf, varia(tname)));
  }
  if (uWhnf.tag === "Lam") {
    const uname = uWhnf.name;
    const ubody = uWhnf.body;
    const local = jc.local.slice();
    local.push(ctxElem(uname, uWhnf.type));
    return ahEq(judgCtx(jc.global, local), app(tWhnf, varia(uname)), ubody);
  }
  return alphaEq(tWhnf, uWhnf);
}

export function wellFormed(jc: JudgContext): Result<true, WFError> {
  const g: Context = [];
  const l: Context = [];
  const check = (ctx: JudgContext, e: CtxElement): Result<true, WFError> => {
    if (e.tag === "Var") {
      const r = typeInfer(ctx, e.type);
      if (isErr(r))
        return err({ error: r.err, at: e });
      if (r.value.tag !== "Sort")
        return err({
          error: { tag: "ExpectedSort", actual: r.value },
          at: e,
        });
      return succ(true);
    } else {
      const r = typeCheck(ctx, e.def, e.type);
      if (isErr(r))
        return err({ error: r.err, at: e });
      return succ(true);
    }
  };
  for (const e of jc.global) {
    const r = check(judgCtx(g, l), e);
    if (isErr(r))
      return r;
    g.push(e);
  }
  for (const e of jc.local) {
    const r = check(judgCtx(g, l), e);
    if (isErr(r))
      return r;
    l.push(e);
  }
  return succ(true);
}

function typeInfer(jc: JudgContext, t: Term): Result<Term, TypeError> {
  switch (t.tag) {
    case "Sort": {
      if (t.name === "Type")
        return err({ tag: "TypeHasNoType" });
      return succ(sort("Type"));
    }
    case "Var": {
      const le = jc.local.slice().reverse().find(e => e.name === t.name);
      if (le)
        return succ(le.type);
      const ge = jc.global.slice().reverse().find(e => e.name === t.name);
      if (ge)
        return succ(ge.type);
      return err({ tag: "UnboundVariable", name: t.name });
    }
    case "Lam": {
      const local = jc.local.slice();
      local.push(ctxElem(t.name, t.type));
      const bodyType = typeInfer(judgCtx(jc.global, local), t.body);
      if (isErr(bodyType))
        return bodyType;
      const termType = pi(t.name, t.type, bodyType.value);
      const s = typeInfer(jc, termType);
      if (isErr(s))
        return s;
      const sNF = headNF(dszNF(jc, s.value));
      if (sNF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: sNF });
      return succ(termType);
    }
    case "Pi": {
      const s0 = typeInfer(jc, t.type);
      if (isErr(s0))
        return s0;
      const s0NF = headNF(dszNF(jc, s0.value));
      if (s0NF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: s0NF });
      const local = jc.local.slice();
      local.push(ctxElem(t.name, t.type));
      const s1 = typeInfer(judgCtx(jc.global, local), t.body);
      if (isErr(s1))
        return s1;
      const s1NF = headNF(dszNF(jc, s1.value));
      if (s1NF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: s1NF });
      return succ(s1NF);
    }
    case "Pair": {
      if (t.as) {
        const asCheck = typeCheck(jc, t, t.as);
        if (isErr(asCheck))
          return asCheck;
        return succ(t.as);
      } else {
        const firstType = typeInfer(jc, t.fst);
        if (isErr(firstType))
          return firstType;
        const secondType = typeInfer(jc, t.snd);
        if (isErr(secondType))
          return secondType;
        return succ(sig("_", firstType.value, secondType.value));
      }
    }
    case "Fst": {
      const pairType = typeInfer(jc, t.pair);
      if (isErr(pairType))
        return pairType;
      const pairTypeNF = headNF(dszNF(jc, pairType.value));
      if (pairTypeNF.tag !== "Sig")
        return err({ tag: "ExpectedSigma", pair: t.pair, actual: pairTypeNF });
      return succ(pairTypeNF.type);
    }
    case "Snd": {
      const pairType = typeInfer(jc, t.pair);
      if (isErr(pairType))
        return pairType;
      const pairTypeNF = headNF(dszNF(jc, pairType.value));
      if (pairTypeNF.tag !== "Sig")
        return err({ tag: "ExpectedSigma", pair: t.pair, actual: pairTypeNF });
      return succ(subst(pairTypeNF.body, pairTypeNF.name, fst(t.pair)));
    }
    case "Sig": {
      const s0 = typeInfer(jc, t.type);
      if (isErr(s0))
        return s0;
      const s0NF = headNF(dszNF(jc, s0.value));
      if (s0NF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: s0NF });
      const local = jc.local.slice();
      local.push(ctxElem(t.name, t.type));
      const s1 = typeInfer(judgCtx(jc.global, local), t.body);
      if (isErr(s1))
        return s1;
      const s1NF = headNF(dszNF(jc, s1.value));
      if (s1NF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: s1NF });
      if ((s0NF.name === "Prop" && s1NF.name === "Prop")
        || s1NF.name === "Type")
        return succ(s1NF);
      return err({
        tag: "ImpossibleCombination",
        sort0: s0NF.name,
        sort1: s1NF.name,
      });
    }
    case "Let": {
      let defType: Term;
      if (t.type) {
        const defCheck = typeCheck(jc, t.def, t.type);
        if (isErr(defCheck))
          return defCheck;
        defType = t.type;
      } else {
        const defInfer = typeInfer(jc, t.def);
        if (isErr(defInfer))
          return defInfer;
        defType = defInfer.value;
      }
      const local = jc.local.slice();
      local.push(ctxElem(t.name, defType, t.def));
      const bodyType = typeInfer(judgCtx(jc.global, local), t.body);
      if (isErr(bodyType))
        return bodyType;
      return succ(subst(bodyType.value, t.name, t.def));
    }
    case "App": {
      const funType = typeInfer(jc, t.fun);
      if (isErr(funType))
        return funType;
      const funTypeNF = headNF(dszNF(jc, funType.value));
      if (funTypeNF.tag !== "Pi")
        return err({ tag: "ExpectedPi", fun: t.fun, actual: funTypeNF });
      const argType = typeInfer(jc, t.arg);
      if (isErr(argType))
        return argType;
      if (!ahEq(jc, argType.value, funTypeNF.type))
        return err({ tag: "TypeMismatch", expected: funTypeNF.type, actual: argType.value });
      return succ(subst(funTypeNF.body, funTypeNF.name, t.arg));
    }
  }
}

function typeCheck(jc: JudgContext, t: Term, expected: Term): Result<true, TypeError> {
  switch (t.tag) {
    case "Pair": {
      const expectedNF = headNF(dszNF(jc, expected));
      if (expectedNF.tag !== "Sig")
        return err({ tag: "ExpectedSigma", pair: t, actual: expectedNF });
      const name = expectedNF.name;
      const fstExpected = expectedNF.type
      const fstCheck = typeCheck(jc, t.fst, fstExpected);
      if (isErr(fstCheck))
        return fstCheck;
      const sndExpected = subst(expectedNF.body, expectedNF.name, t.fst);
      const sndCheck = typeCheck(jc, t.snd, sndExpected);
      if (isErr(sndCheck))
        return sndCheck;
      const local = jc.local.slice();
      local.push(ctxElem(name, fstExpected));
      const extendedJc = judgCtx(jc.global, local);
      const s = typeInfer(extendedJc, sndExpected);
      if (isErr(s))
        return s;
      const sNF = headNF(dszNF(extendedJc, s.value));
      if (sNF.tag !== "Sort")
        return err({ tag: "ExpectedSort", actual: sNF });
      return succ(true);
    }
    default: {
      const inferred = typeInfer(jc, t);
      if (isErr(inferred))
        return inferred;
      if (!ahEq(jc, inferred.value, expected))
        return err({ tag: "TypeMismatch", expected, actual: inferred.value });
      return succ(true);
    }
  }
}